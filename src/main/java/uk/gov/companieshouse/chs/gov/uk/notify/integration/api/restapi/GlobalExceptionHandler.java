package uk.gov.companieshouse.chs.gov.uk.notify.integration.api.restapi;

import static uk.gov.companieshouse.chs.gov.uk.notify.integration.api.ChsGovUkNotifyIntegrationService.APPLICATION_NAMESPACE;

import com.lowagie.text.pdf.PdfXConformanceException;
import jakarta.validation.ValidationException;
import java.util.List;
import java.util.Map;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.HttpStatusCode;
import org.springframework.http.ResponseEntity;
import org.springframework.lang.NonNull;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.context.request.WebRequest;
import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler;
import org.thymeleaf.exceptions.TemplateInputException;
import uk.gov.companieshouse.chs.gov.uk.notify.integration.api.exception.LetterNotFoundException;
import uk.gov.companieshouse.chs.gov.uk.notify.integration.api.exception.SvgImageException;
import uk.gov.companieshouse.chs.gov.uk.notify.integration.api.exception.TooManyLettersFoundException;
import uk.gov.companieshouse.logging.Logger;
import uk.gov.companieshouse.logging.util.DataMap;

@ControllerAdvice
public class GlobalExceptionHandler extends ResponseEntityExceptionHandler {

    /**
     * Map of message (part) substitutions to make message more meaningful to human readers.
     * Workaround for fact we probably cannot provide a more meaningful message in
     * the @Pattern annotation in code generated by OpenAPI Generator.
     */
    private static final Map<String, String>
            ERROR_MESSAGE_PARAMETER_NAME_SUBSTITUTIONS =
            Map.of("sendLetter.arg1", "request ID (X-Request-ID)");

    private static final String ERROR_CONTEXT = "Error in " + APPLICATION_NAMESPACE + ": ";
    private static final String WILL_HANDLE = "Will handle error `";

    /** Given this name to avoid any confusion with `ResponseEntityExceptionHandler.logger`. **/
    private final Logger myLogger;

    public GlobalExceptionHandler(Logger logger) {
        this.myLogger = logger;
    }

    /**
     * Returns HTTP Status 400 Bad Request when there is an exception implying that
     * the incoming request content is invalid.
     *
     * @param ve exception thrown when input from request is found to be invalid
     * @return response with payload reporting underlying cause
     */
    @ExceptionHandler(ValidationException.class)
    public ResponseEntity<Object> handleValidationException(
            ValidationException ve) {
        var message = ERROR_CONTEXT + buildMessage(ve.getMessage());
        myLogger.error(WILL_HANDLE + message + "` by responding with 400 Bad Request.",
                getLogMap(message));
        return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                .body(message);
    }

    /**
     * Returns HTTP Status 500 Internal Server Error when there is a TemplateInputException
     * implying that a template resource cannot be found. It does not return a 404 Not Found
     * response because this scenario represents a configuration error as the template lookup
     * must already have found context validation set up for the template identified in the
     * request. Possible underlying problems include the template itself cannot be found in the
     * assets, or a file the template refers to cannot be found in the assets.
     *
     * @param tie exception thrown when there is a fundamental problem with the template the engine
     *            has been directed to process
     * @return response with payload reporting underlying cause
     */
    @ExceptionHandler(TemplateInputException.class)
    public ResponseEntity<Object> handleTemplateInputException(
            TemplateInputException tie) {
        return reportInternalServerError(tie);
    }

    /**
     * Returns HTTP Status 500 Internal Server Error when there is an SvgImageException
     * implying that an SVG resource cannot be found. It does not return a 404 Not Found
     * response because this scenario represents a configuration error.
     *
     * @param sie exception thrown when an SVG resource cannot be found
     * @return response with payload reporting underlying cause
     */
    @ExceptionHandler(SvgImageException.class)
    public ResponseEntity<Object> handleSvgImageException(
            SvgImageException sie) {
        return reportInternalServerError(sie);
    }

    /**
     * Returns HTTP Status 500 Internal Server Error when there is an PdfXConformanceException.
     * Such an exception could imply a missing font or style or even a missing stylesheet,
     * which would be a configuration error.
     *
     * @param pce exception thrown when there is a PDF/A conformance issue
     * @return response with payload reporting underlying cause
     */
    @ExceptionHandler(PdfXConformanceException.class)
    public ResponseEntity<Object> handlePdfXConformanceException(
            PdfXConformanceException pce) {
        return reportInternalServerError(pce,
                ". This PdfXConformanceException could indicate that a font, style or "
                        + "stylesheet cannot be found.");
    }

    /**
     * Returns HTTP Status 404 Not Found when there is an exception implying that
     * a letter sought cannot be found.
     *
     * @param lnfe exception thrown when no letter can be found
     * @return response with payload reporting underlying cause
     */
    @ExceptionHandler(LetterNotFoundException.class)
    public ResponseEntity<Object> handleLetterNotFoundException(
            LetterNotFoundException lnfe) {
        var message = ERROR_CONTEXT + buildMessage(lnfe.getMessage());
        myLogger.error(WILL_HANDLE + message + "` by responding with 404 Not Found.",
                getLogMap(message));
        return ResponseEntity.status(HttpStatus.NOT_FOUND)
                .body(message);
    }

    /**
     * Returns HTTP Status 409 Conflict when there is an exception implying that
     * more than a single instance of a what should be a uniquely identified letter
     * sought have been found.
     *
     * @param tmlfe exception thrown when too many letters are found
     * @return response with payload reporting underlying cause
     */
    @ExceptionHandler(TooManyLettersFoundException.class)
    public ResponseEntity<Object> handleTooManyLettersFoundException(
            TooManyLettersFoundException tmlfe) {
        var message = ERROR_CONTEXT + buildMessage(tmlfe.getMessage());
        myLogger.error(WILL_HANDLE + message + "` by responding with 409 Conflict.",
                getLogMap(message));
        return ResponseEntity.status(HttpStatus.CONFLICT)
                .body(message);
    }

    @Override
    protected ResponseEntity<Object> handleMethodArgumentNotValid(
            @NonNull MethodArgumentNotValidException manve,
            @NonNull HttpHeaders headers,
            @NonNull HttpStatusCode status,
            @NonNull WebRequest request) {
        if (manve.hasFieldErrors()) {
            var errors = manve.getFieldErrors().stream()
                    .map(this::buildMessage)
                    .sorted()
                    .toList();
            var message = "Error(s) in " + APPLICATION_NAMESPACE + ": " + errors;
            myLogger.error(message, getLogMap(errors));
            return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                    .body(message);
        }

        return super.handleMethodArgumentNotValid(manve, headers, status, request);
    }

    /**
     * Returns HTTP Status 500 Internal Server Error for the runtime exception provided.
     *
     * @param re An exception suggesting a programming or configuration error has arisen
     * @return HttpStatus.INTERNAL_SERVER_ERROR
     */
    private ResponseEntity<Object> reportInternalServerError(RuntimeException re) {
        return reportInternalServerError(re, null);
    }

    /**
     * Returns HTTP Status 500 Internal Server Error for the runtime exception provided.
     *
     * @param re An exception suggesting a programming or configuration error has arisen
     * @param additionalMessage an additional message - this may be <code>null</code>
     * @return HttpStatus.INTERNAL_SERVER_ERROR
     */
    private ResponseEntity<Object> reportInternalServerError(RuntimeException re,
                                                             String additionalMessage) {
        var message = ERROR_CONTEXT + buildMessage(re.getMessage()
                + " [cause: " + re.getCause() + "]"
                + (additionalMessage != null ? additionalMessage : ""));
        myLogger.error(WILL_HANDLE + message
                        + "` by responding with 500 Internal Server Error.",
                getLogMap(message));
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(message);
    }

    /**
     * Provides a more legible/meaningful substitution for part of a message originating from a
     * low level exception.
     * 
     * @param exceptionMessage the message provided by the intercepted exception
     * @return the sanitised version of the message
     */
    private String buildMessage(String exceptionMessage) {
        var newMessage = exceptionMessage;
        for (Map.Entry<String, String> entry :
                ERROR_MESSAGE_PARAMETER_NAME_SUBSTITUTIONS.entrySet()) {
            newMessage = newMessage.replace(entry.getKey(), entry.getValue());
        }
        return newMessage;
    }

    /**
     * Builds an intelligible error message from the {@link FieldError} provided.
     * @param fieldError the error to be reported
     * @return the error message
     */
    private String buildMessage(FieldError fieldError) {
        return fieldError.getObjectName() + " "
                + fieldError.getField() + " "
                + fieldError.getDefaultMessage();
    }

    private Map<String, Object> getLogMap(String error) {
        return new DataMap.Builder()
                .errorMessage(error)
                .build()
                .getLogMap();
    }

    private Map<String, Object> getLogMap(List<String> errors) {
        return new DataMap.Builder()
                .errors(errors)
                .build()
                .getLogMap();
    }

}
